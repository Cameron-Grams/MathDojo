read me:  https://woutr.me/2017/01/01/authenticating-with-json-web-tokens.html

9 Oct
differences after work:
- changed the name of the properties being searched for in MongoDB
- bcrypt requiring Object specification?  Forces the inclusion of properties by commision rather than ommission...; jwt.sign( ... ) line 110 sessionRouter.js 

- dashboard 'checkUser()' function;
    - to dashboard authorization endpoint on router
    - header contains an Authorization property
    - success/ error actions
    - localStorage to hold the JWT; set in the login-logic.js, calls dashboard.html 
        - dashboard-logic.js checks to make sure the JWT is present for the dashboard page before permitting data to be displayed.
    - specification of the operation in the call to dashboard...
    - including the http status on the response object from the server ( Promise function); prevents an incorrect response being sent through by default

--more explanation of the basicStrategy.js  ?? 
--CORS? 

------------------------------

12 Oct
To Do:
- format login entries

- login process; establish new account then dashboard...

- logout feature

- dashboard display
  - past performance; graph? 

- dashboard select/ end training



-------------------
Stackoverflow question;

The goal of this program is to add a property to the problem objects called 'userResponse' that reflects the input from the user.  The problem object in Mongo DB is held in an array of objects, called 'problems', that is held in an object called 'session':

```
{
	"_id" : ObjectId("59df5ee7adb378237377dbb4"),
	"updatedAt" : ISODate("2017-10-12T12:24:07.269Z"),
	"createdAt" : ISODate("2017-10-12T12:24:07.269Z"),
	"userId" : "59df5edbadb378237377dbb3",
	"problems" : [
		{
			"correctResponse" : 23,
			"problem" : "20 + 3",
			"secondTerm" : 3,
			"firstTerm" : 20
                } ]
}
```
  
Here is the logic for the endpoint that I have been using: 

```
router.patch( '/session/:sessionId/:index', passport.authenticate( 'jwt', { session: false } ), ( req, res ) => {
    Session.findOne({_id: req.params.sessionId})
    .then( (item)=>{
        item.problems[req.params.index].userResponse = req.body.userResponse;
        Session.update({_id: req.params.sessionId}, item).then( (updated)=>{
          res.json(updated.problems[req.params.index]);
        }); 
    })

}) 
```

I looked at some other examples ( [one](https://stackoverflow.com/questions/4669178/how-to-update-multiple-array-elements-in-mongodb) [two](https://stackoverflow.com/questions/10522347/mongodb-update-objects-in-a-documents-array-nested-updating) ) but they do not seem relavant since this is a patch to single elements of the array as identified by the params.  

This approach works, in that it successfully updates the database with the new properties on the objects, but during the execution the server logs this error:

(node:10955) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: Cannot read property '0' of undefined

My understanding is that this means the object can not be found in the database at some point, but since the database does include the new properties it must be resolved later.  Is that corrrect?   

Additionally it seems brittle to have two chained promises with no catch statements...

Can anyone offer suggestions on how to improve this process?  This logic does successfully update the database, with errors.  Is there a better way? 

Thank you for your time.  















